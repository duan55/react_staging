{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\\\u9648\\u9E3F\\u68EE\\\\Desktop\\\\react_staging\\\\src\\\\components\\\\Search\\\\index.jsx\";\nimport React, { Component } from 'react';\nimport axios from 'axios';\nimport PubSub from 'pubsub-js';\nimport { error } from 'ajv/dist/vocabularies/applicator/dependencies';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class search extends Component {\n  constructor(...args) {\n    super(...args);\n    //用户搜索(使用axios)\n    this.searchUserAxios = () => {\n      //1.获取用户的输入，button绑定了事件但是要获取input的输入需要使用ref、受控组件表单\n      //连续解构赋值直接获取到value并将其重命名为keyword，但是后文如果去取inputSth则会提示并没有解构得到inputSth\n      const {\n        inputSth: {\n          value: keyword\n        }\n      } = this;\n      //1.2 发送请求前通知List更新state\n      PubSub.publish('github user info', {\n        isFirst: false,\n        isLoading: true,\n        error: null\n      });\n      //2.发送网络请求\n      //github后端使用cors解决了跨域问题，不再需要设置setupProxy.js\n      //练习需要使用sgg提供的服务器访问地址\n      // axios.get(`http://localhost:3000/api1/search/users?q=${keyword}`).then( 发送的位置就是访问的位置，则http://ip+端口可以不写\n      axios.get(`/api1/search/users2?q=${keyword}`).then(response => {\n        //通知List更新state\n        PubSub.publish('github user info', {\n          isFirst: false,\n          isLoading: false,\n          users: response.data.items\n        });\n      }, error => {\n        //通知List更新state\n        //此处不能直接存入错误对象，而是要存入错误对象的属性\n        PubSub.publish('github user info', {\n          isFirst: false,\n          isLoading: false,\n          error: error.message\n        });\n      });\n    };\n    //用户搜索(使用fetch) 初版\n    this.searchUserUnoptimized = () => {\n      //1.获取用户的输入\n      const {\n        inputSth: {\n          value: keyword\n        }\n      } = this;\n      //1.2 发送请求前通知List更新state\n      PubSub.publish('github user info', {\n        isFirst: false,\n        isLoading: true,\n        error: null\n      });\n      //2.发送网络请求\n      fetch(`/api1/search/users2?q=${keyword}`).then(response => {\n        //404也算联系成功，只要是有响应都算链接成功\n        console.log('链接服务器成功', response);\n        //通知List更新state\n        //PubSub.publish('github user info', { isFirst: false, isLoading: false, users: response.data.items })\n        //如果链接到服务器成功，则调用json方法\n        return response.json();\n      }, error => {\n        console.log('链接服务器失败', error); //如果失败的回调输出一行字，那么下面的then不会进到error中，因为会返回undefined(非promise值)状态为成功\n        //手工中断\n        return new Promise(() => {});\n        //通知List更新state\n        // PubSub.publish('github user info', { isFirst: false, isLoading: false, error: error.message })\n      }).then(\n      //.then 能够链式调用的一个原因就是其返回值也可以是一个Promise实例对象从而再次被.then使用\n      //如果上一级返回不是一个promise实例，那么状态就默认为成功，值就为非promise值\n      //如果是一个promise实例，则状态和值都与其一致，将作为下一个.then的promise入参进行使用，如抛出一个异常，则状态就为异常 且 值为错误的原因\n      response => {\n        console.log(\"获取数据成功\", response);\n      }, error => {\n        console.log(\"获取数据失败\", error);\n      });\n    };\n    //用户搜索(使用fetch) 2.0\n    this.searchUserOptimizedHalf = () => {\n      //1.获取用户的输入\n      const {\n        inputSth: {\n          value: keyword\n        }\n      } = this;\n      //1.2 发送请求前通知List更新state\n      PubSub.publish('github user info', {\n        isFirst: false,\n        isLoading: true,\n        error: null\n      });\n      //2.发送网络请求\n      fetch(`/api1/search/users2?q=${keyword}`).then(response => {\n        //404也算联系成功，只要是有响应都算链接成功\n        console.log('链接服务器成功', response);\n        //通知List更新state\n        //PubSub.publish('github user info', { isFirst: false, isLoading: false, users: response.data.items })\n        //如果链接到服务器成功，则调用json方法\n        return response.json();\n      }).then(\n      //.then 能够链式调用的一个原因就是其返回值也可以是一个Promise实例对象从而再次被.then使用\n      //如果上一级返回不是一个promise实例，那么状态就默认为成功，值就为非promise值\n      //如果是一个promise实例，则状态和值都与其一致，将作为下一个.then的promise入参进行使用，如抛出一个异常，则状态就为异常 且 值为错误的原因\n      response => {\n        console.log(\"获取数据成功\", response);\n      }).catch(\n      //.catch可以指定一个回调函数来处理Promise实例对象中发生的错误\n      error => {\n        console.log(\"!什么东西出错了!!\", error);\n      });\n    };\n    //用户搜索(使用fetch) 3.0 不需要使用两次.then的链式调用来获取结果\n    this.searchUser = async () => {\n      //1.获取用户的输入\n      const {\n        inputSth: {\n          value: keyword\n        }\n      } = this;\n      //1.2 发送请求前通知List更新state\n      PubSub.publish('github user info', {\n        isFirst: false,\n        isLoading: true,\n        error: null\n      });\n      //2.发送网络请求获取Promise对象 \n      try {\n        //2.1 await只会等到成功的结果，遇到错误会忽略 因此需要使用try...catch\n        const response = await fetch(`/api1/search/users2?q=${keyword}`);\n        //2.2 获取Promise中的value结果\n        const result = await response.json();\n        console.log(result);\n      } catch (error) {\n        console.log(\"!什么东西出错了!!\", error);\n      }\n    };\n    //键入回车直接搜索\n    this.searchTrigger = event => {\n      const {\n        key,\n        target\n      } = event;\n      //检测到'回车'\n      if (key === 'Enter') {\n        //去完空格之后如果无实质内容则报错提示\n        if (target.value.trim() === '') {\n          alert('输入不能为空');\n          return;\n        }\n        this.searchUser();\n        target.value = '';\n      }\n    };\n  }\n  //渲染\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"section\", {\n      className: \"jumbotron\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        className: \"jumbotron-heading\",\n        children: \"\\u641C\\u7D22Github\\u7528\\u6237\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 140,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(\"input\", {\n          ref: c => this.inputSth = c,\n          type: \"text\",\n          placeholder: \"\\u8F93\\u5165\\u9700\\u8981\\u641C\\u7D22\\u7684\\u7528\\u6237\\u540D\",\n          onKeyUp: this.searchTrigger\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 142,\n          columnNumber: 21\n        }, this), \"\\xA0\", /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: this.searchUser,\n          children: \"\\u641C\\u7D22\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 143,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 141,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 13\n    }, this);\n  }\n}","map":{"version":3,"names":["React","Component","axios","PubSub","error","jsxDEV","_jsxDEV","search","constructor","args","searchUserAxios","inputSth","value","keyword","publish","isFirst","isLoading","get","then","response","users","data","items","message","searchUserUnoptimized","fetch","console","log","json","Promise","searchUserOptimizedHalf","catch","searchUser","result","searchTrigger","event","key","target","trim","alert","render","className","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","c","type","placeholder","onKeyUp","onClick"],"sources":["C:/Users/陈鸿森/Desktop/react_staging/src/components/Search/index.jsx"],"sourcesContent":["import React, { Component } from 'react'\r\nimport axios from 'axios'\r\nimport PubSub from 'pubsub-js'\r\nimport { error } from 'ajv/dist/vocabularies/applicator/dependencies'\r\n\r\n\r\nexport default class search extends Component {\r\n\r\n    //用户搜索(使用axios)\r\n    searchUserAxios = () => {\r\n        //1.获取用户的输入，button绑定了事件但是要获取input的输入需要使用ref、受控组件表单\r\n        //连续解构赋值直接获取到value并将其重命名为keyword，但是后文如果去取inputSth则会提示并没有解构得到inputSth\r\n        const { inputSth: { value: keyword } } = this\r\n        //1.2 发送请求前通知List更新state\r\n        PubSub.publish('github user info', { isFirst: false, isLoading: true, error: null })\r\n        //2.发送网络请求\r\n        //github后端使用cors解决了跨域问题，不再需要设置setupProxy.js\r\n        //练习需要使用sgg提供的服务器访问地址\r\n        // axios.get(`http://localhost:3000/api1/search/users?q=${keyword}`).then( 发送的位置就是访问的位置，则http://ip+端口可以不写\r\n        axios.get(`/api1/search/users2?q=${keyword}`).then(\r\n            response => {\r\n                //通知List更新state\r\n                PubSub.publish('github user info', { isFirst: false, isLoading: false, users: response.data.items })\r\n            },\r\n            error => {\r\n                //通知List更新state\r\n                //此处不能直接存入错误对象，而是要存入错误对象的属性\r\n                PubSub.publish('github user info', { isFirst: false, isLoading: false, error: error.message })\r\n            }\r\n        )\r\n    }\r\n\r\n    //用户搜索(使用fetch) 初版\r\n    searchUserUnoptimized = () => {\r\n        //1.获取用户的输入\r\n        const { inputSth: { value: keyword } } = this\r\n        //1.2 发送请求前通知List更新state\r\n        PubSub.publish('github user info', { isFirst: false, isLoading: true, error: null })\r\n        //2.发送网络请求\r\n        fetch(`/api1/search/users2?q=${keyword}`).then(\r\n            response => {\r\n                //404也算联系成功，只要是有响应都算链接成功\r\n                console.log('链接服务器成功',response)\r\n                //通知List更新state\r\n                //PubSub.publish('github user info', { isFirst: false, isLoading: false, users: response.data.items })\r\n                //如果链接到服务器成功，则调用json方法\r\n                return response.json()\r\n            },\r\n            error => {\r\n                console.log('链接服务器失败',error)//如果失败的回调输出一行字，那么下面的then不会进到error中，因为会返回undefined(非promise值)状态为成功\r\n                //手工中断\r\n                return new Promise(()=>{})\r\n                //通知List更新state\r\n                // PubSub.publish('github user info', { isFirst: false, isLoading: false, error: error.message })\r\n            }\r\n        ).then(\r\n            //.then 能够链式调用的一个原因就是其返回值也可以是一个Promise实例对象从而再次被.then使用\r\n            //如果上一级返回不是一个promise实例，那么状态就默认为成功，值就为非promise值\r\n            //如果是一个promise实例，则状态和值都与其一致，将作为下一个.then的promise入参进行使用，如抛出一个异常，则状态就为异常 且 值为错误的原因\r\n            response => {\r\n                console.log(\"获取数据成功\", response)\r\n            },\r\n            error => {\r\n                console.log(\"获取数据失败\", error)\r\n            }\r\n        )\r\n    }\r\n\r\n    //用户搜索(使用fetch) 2.0\r\n    searchUserOptimizedHalf = () => {\r\n        //1.获取用户的输入\r\n        const { inputSth: { value: keyword } } = this\r\n        //1.2 发送请求前通知List更新state\r\n        PubSub.publish('github user info', { isFirst: false, isLoading: true, error: null })\r\n        //2.发送网络请求\r\n        fetch(`/api1/search/users2?q=${keyword}`).then(\r\n            response => {\r\n                //404也算联系成功，只要是有响应都算链接成功\r\n                console.log('链接服务器成功',response)\r\n                //通知List更新state\r\n                //PubSub.publish('github user info', { isFirst: false, isLoading: false, users: response.data.items })\r\n                //如果链接到服务器成功，则调用json方法\r\n                return response.json()\r\n            },\r\n        ).then(\r\n            //.then 能够链式调用的一个原因就是其返回值也可以是一个Promise实例对象从而再次被.then使用\r\n            //如果上一级返回不是一个promise实例，那么状态就默认为成功，值就为非promise值\r\n            //如果是一个promise实例，则状态和值都与其一致，将作为下一个.then的promise入参进行使用，如抛出一个异常，则状态就为异常 且 值为错误的原因\r\n            response => {\r\n                console.log(\"获取数据成功\", response)\r\n            },\r\n        ).catch(\r\n            //.catch可以指定一个回调函数来处理Promise实例对象中发生的错误\r\n            error => {\r\n                console.log(\"!什么东西出错了!!\", error)\r\n            }\r\n        )\r\n    }\r\n\r\n    //用户搜索(使用fetch) 3.0 不需要使用两次.then的链式调用来获取结果\r\n    searchUser = async () => {\r\n        //1.获取用户的输入\r\n        const { inputSth: { value: keyword } } = this\r\n        //1.2 发送请求前通知List更新state\r\n        PubSub.publish('github user info', { isFirst: false, isLoading: true, error: null })\r\n        //2.发送网络请求获取Promise对象 \r\n        try\r\n        {\r\n            //2.1 await只会等到成功的结果，遇到错误会忽略 因此需要使用try...catch\r\n            const response = await fetch(`/api1/search/users2?q=${keyword}`)\r\n            //2.2 获取Promise中的value结果\r\n            const result = await response.json()\r\n            console.log(result)\r\n        }\r\n        catch(error){\r\n            console.log(\"!什么东西出错了!!\", error)\r\n        }\r\n\r\n    }\r\n\r\n    //键入回车直接搜索\r\n    searchTrigger = (event) => {\r\n        const { key, target } = event\r\n        //检测到'回车'\r\n        if (key === 'Enter') {\r\n            //去完空格之后如果无实质内容则报错提示\r\n            if (target.value.trim() === '') {\r\n                alert('输入不能为空')\r\n                return;\r\n            }\r\n            this.searchUser()\r\n            target.value = ''\r\n        }\r\n    }\r\n\r\n    //渲染\r\n    render() {\r\n        return (\r\n            <section className=\"jumbotron\">\r\n                <h3 className=\"jumbotron-heading\">搜索Github用户</h3>\r\n                <div>\r\n                    <input ref={c => this.inputSth = c} type=\"text\" placeholder=\"输入需要搜索的用户名\" onKeyUp={this.searchTrigger} />&nbsp;\r\n                    <button onClick={this.searchUser}>搜索</button>\r\n                </div>\r\n            </section>\r\n        )\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}